<!DOCTYPE html>
<head>
    <script>
        window.MathJax = {
          tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
          svg: { fontCache: 'global' }
        };
      </script>
      <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
</head>
<body>
    <H1 id="experimentName" class="editable">Enter Experiment Name</H1>
    <div style="display: flex; flex-direction: row;">
    <div id="experimentContent">
        <div><b>Aim:</b></div>
        <div id="experimentAim" class="editable" autofocus></div>
        <div><b>Body:</b></div>
        <div id="experimentBody" class="editable" autofocus></div>
        <div><b>Conclusion:</b></div>
        <div id="experimentConclusion" class="editable" autofocus></div>
    </div>
    <div id="relatedExperiments">
        <div id="followUpExperiments">
            <div><b>Follow Up experiments</b></div>
            <div id="followUpExperimentsList"></div>
            <div id="followUpExerimentCreator" style="display: flex; flex-direction: row;">
                <div id="enterFollowUpExperimentName" data-raw = '' placeholder ='Create a follow up experiment' class="relatedExperimentsEditable" contenteditable="true">Create a follow up experiment</div>
                <button id="createFollowUpExperiment" class="button">Create</button>
            </div>
        </div>
        <div id="referenceExperiments"><b>Reference Experiments</b>
            <div id="referenceExperimentsList"></div>
        </div>
    </div>
    </div>

    <script>
        const pathParts = window.location.pathname.split('/');
        const pageOperation = pathParts[2];

        //timeout variable to help create a buffer when saving changes to editable fields
        let inputTimeout;
        let modifiedFieldsArray = [];


        // setting fields that can be edited to be editable
        const editablefields = document.querySelectorAll('.editable');
        editablefields.forEach(field => {
            field.contentEditable = 'true';
        });

        const followUpCreatorInput = document.getElementById('enterFollowUpExperimentName');
        const followUpCreatorButton = document.getElementById('createFollowUpExperiment');
        const followUpExperimentsList = document.getElementById('followUpExperimentsList');
        const referenceExperimentsList = document.getElementById('referenceExperimentsList')
        
        hoverPlaceholderManagement(followUpCreatorInput)

        // converts fields to latex formatting when not in focus
        editablefields.forEach(field => {
            field.addEventListener('focus', () => {
                field.innerHTML = field.getAttribute('data-raw');
            })
            field.addEventListener('blur', () => {
                MathJax.typesetPromise([field]).catch((err)=>{console.error(err)});
            })
        })
        
        // new experiment mode for a new experiment being created
        if (pageOperation == 'new'){
            /* function that watches any for edits done on the new experiment, then calls the server to create new database entry for that experiment with the added content and exists new experiment mode*/
            function fieldEditListener(e) {
                const field = e.currentTarget;
                clearTimeout(inputTimeout);
                field.setAttribute('data-raw', field.textContent);

                // tracks the fields where changes have been made
                if(!modifiedFieldsArray.includes(field)){
                    modifiedFieldsArray.push(field)
                }

                // waits for three seconds of inactivity before triggering database entry creation for the new experiment
                inputTimeout = setTimeout(async ()=> { 
                        //sends modfied info to the server and recieves experiment id (eId) for the new database row entry created
                        const response = await fetch('/experiment/new/firstSave', {
                            method: 'post',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({modifiedField: field.id, modifiedFieldContent: field.textContent})
                        })
                        // dealing with response: changes the url to /experiment/eId and close all event listeners created inside this if statement
                        try{
                            if(!response.ok){
                                const responseContent = await response.json();
                                throw responseContent;
                            }
                            const responseContent = await response.json();
                            console.log('created experiment with id ', responseContent.eId);

                            //changes the url to /experiment/eId
                            const newPathname = `/experiment/open?eId=${responseContent.eId}`;
                            const newUrl = window.location.origin + newPathname + window.location.search + window.location.hash;
                            history.replaceState({}, '', newUrl);

                            //removes all event listeners created inside this if statement helping quit the new experiment mode
                            editablefields.forEach(field => {
                                field.removeEventListener('input', fieldEditListener)
                             })
                            
                            sendDataToBeSaved(responseContent.eId)
                            openPageMaintenance();
                        }catch(err){
                            console.error(err);
                        }
                },3000);
            };
            //creates event listeners to all editable fields
            editablefields.forEach(field => {
                field.addEventListener('input', fieldEditListener)
            })
        }
        
        // loading an experiment that already exists in the database
        if(pageOperation == 'open'){
            const urlParams = new URLSearchParams(window.location.search);
            fillExperimentData(urlParams.get('eId'));
            getFollowUpExperiments(urlParams.get('eId'));
            getReferences(urlParams.get('eId'));
            openPageMaintenance();
        }

        //getting details for experiment by eId
        async function fillExperimentData(eId){
            try{
                const response = await fetch(`/experiment/getData?eId=${eId}`)
                if(!response.ok){
                    const responseContent = await response.json();
                    console.error(responseContent)
                }
                console.log('getting data from server')
                const responseContent = await response.json();

                console.log('updating the page with received experiment details');
                // updating each editable field with data stored in server
                editablefields.forEach(field => {
                    const fieldId = field.id;
                    field.setAttribute('data-raw', responseContent[fieldId]);
                    field.innerHTML = responseContent[fieldId];
                    // renders latex blocks inside the div 
                    MathJax.typesetPromise([field]).catch((err)=>{console.error(err)});
                })
            }catch(err){
                console.error(err);
            }
        }

        //managing all active functions after page load or initial save
        async function openPageMaintenance(){
            //event listeners for saving any changes made
            editablefields.forEach(field => {
                field.addEventListener('input', saveExperimentChanges);
            })
        }

        //saving changes to editable fields
        async function saveExperimentChanges(e){
            
            const field = e.currentTarget;
            clearTimeout(inputTimeout);

            const urlParams = new URLSearchParams(window.location.search);
            const eId = urlParams.get('eId');

            // tracks the fields where changes have been made
            if(!modifiedFieldsArray.includes(field)){
                modifiedFieldsArray.push(field)
            }

            // saves the new text content to the attribute for latex handling
            field.setAttribute('data-raw', field.textContent);
            
            //waits to builds a buffer of changes to be saved across different fields and sends aggregated data to the server
            inputTimeout = setTimeout(async () => {                
                sendDataToBeSaved(eId)
            }, 3000)

        }

        // sends all changes to the server to be saved
        async function sendDataToBeSaved(eId){
            let modifiedData = [];    
            modifiedFieldsArray.forEach(arrayElement => {
                modifiedData.push({modifiedField: arrayElement.id, modifiedFieldContent: arrayElement.getAttribute('data-raw')})
            })

            try{
                const response = await fetch(`/experiment/saveData?eId=${eId}`, {
                    method: 'post',
                    headers:{
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(modifiedData)
                })
                if(!response.ok){
                    const responseContent = await response.json();
                    console.error(responseContent)
                }
                const responseContent = await response.json();
                console.log(responseContent.message);
                modifiedFieldsArray = [];
            } catch(err){
                console.error(err)
            }
        }

        relatedExperimentsMaintenance();

        // maintains functions concerned with creating and managing related experiments
        async function relatedExperimentsMaintenance(){
            // deals with creation of a new follow up experiment
            createFollowUpExperiment();    
        }
        
        async function createFollowUpExperiment(){
            
            // manages text entered in follow up experiment creation input field
            followUpCreatorInput.addEventListener('input', ()=>{
                followUpCreatorInput.setAttribute('data-raw', followUpCreatorInput.textContent);
            })
            
            // listens if follow up button is clicked or not
            followUpCreatorButton.addEventListener('click', async () => {
                if(window.location.pathname.split('/')[2] == 'new'){
                    console.log("Enter experiment name before creating a follow up")
                }else{
                    if(followUpCreatorInput.getAttribute('data-raw')==''){
                        console.log("enter follow up experiment name");
                    }else{
                        console.log("creating experiment", followUpCreatorInput.getAttribute('data-raw'));
                        saveNewFollowUpExperimentInfo();
                    }
                    
                }
            })

            // sends infromation to the create the follow up experiment to the server and returns the new experiment no
            async function saveNewFollowUpExperimentInfo(){
                urlParams = new URLSearchParams(window.location.search);
                try{
                    const response = await fetch(`/relatedExperiment/createFollowUp?eId=${urlParams.get('eId')}`, {
                        method : 'post',
                        headers : {
                            'Content-Type' : 'application/json' 
                        },
                        body : JSON.stringify({modifiedField: 'experimentName', modifiedFieldContent : `${followUpCreatorInput.getAttribute('data-raw')}`})
                    })
                    if(!response.ok){
                        const responseContent = await response.json();
                        console.error(responseContent)
                    };

                    //recieves the eId of the new follow up experiment created and the status of creating the link as {eId: #, message: 'message'}
                    const responseContent = await response.json();
                    addNewFollowUpToList(responseContent.eId, followUpCreatorInput.getAttribute('data-raw'));
                }catch(err){
                    console.error(err)
                }
            }     
        }

        // creates a follow up item and adds it to the list of follow up experiments
        async function addNewFollowUpToList(eId, experimentName) {

            const followUpExperimentItem = document.createElement('div');
            const followUpExperimentLink = document.createElement('div');

            const followUpExperimentLinkText = document.createElement('a');
            followUpExperimentLinkText.href = `/experiment/open?eId=${eId}`;
            followUpExperimentLinkText.textContent = `${experimentName}`;

            const editFollowUpExperimentName = document.createElement('button');
            editFollowUpExperimentName.textContent = 'Edit';


            followUpExperimentLink.appendChild(followUpExperimentLinkText);
            followUpExperimentItem.appendChild(followUpExperimentLink);
            followUpExperimentItem.appendChild(editFollowUpExperimentName);
            followUpExperimentsList.appendChild(followUpExperimentItem);
            followUpCreatorInput.textContent =  followUpCreatorInput.getAttribute('placeholder');
            followUpCreatorInput.setAttribute('data-raw', '');
        }


        async function getFollowUpExperiments(eId){
            try{
                console.log('getting follow up experiments')
                const response = await fetch(`/relatedExperiment/getFollowUp`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({eId: eId})
                })
                if(!response.ok){
                    const responseContent = await response.json();
                    console.error(responseContent)
                };
                const responseContent = await response.json();
                if(responseContent!=null){
                    console.log(responseContent)
                    responseContent.forEach(experiment => {
                        addNewFollowUpToList(experiment.eId, experiment.experimentName);
                    })
                }
            }catch(err){
                console.error(err)
            }
        }

        async function addNewReferenceToList(eId, experimentName) {

            const referenceExperimentItem = document.createElement('div');
            const referenceExperimentLink = document.createElement('div');

            const referenceExperimentLinkText = document.createElement('a');
            referenceExperimentLinkText.href = `/experiment/open?eId=${eId}`;
            referenceExperimentLinkText.textContent = `${experimentName}`;

            const editReferenceExperimentName = document.createElement('button');
            editReferenceExperimentName.textContent = 'Edit';


            referenceExperimentLink.appendChild(referenceExperimentLinkText);
            referenceExperimentItem.appendChild(referenceExperimentLink);
            referenceExperimentItem.appendChild(editReferenceExperimentName);
            referenceExperimentsList.appendChild(referenceExperimentItem);
            }

        async function getReferences(eId){
            try{
                console.log('getting referenced experiments')
                const response = await fetch(`/relatedExperiment/getReferences`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({eId: eId})
                })
                if(!response.ok){
                    const responseContent = await response.json();
                    console.error(responseContent)
                };
                const responseContent = await response.json();
                if(responseContent!=null){
                    console.log(responseContent)
                    responseContent.forEach(experiment => {
                        addNewReferenceToList(experiment.eId, experiment.experimentName);
                    })
                }
            }catch(err){
                console.error(err)
            }
        }

        // manages replacing editable field with placer holder text if it is empty
        async function hoverPlaceholderManagement(field) {
            field.addEventListener('focus', ()=>{
                if(field.getAttribute('data-raw') == ''){
                    field.innerHTML = ''
                }
            })
            field.addEventListener('blur', ()=>{
                if(field.getAttribute('data-raw') == ''){
                    field.innerHTML = field.getAttribute('placeholder');
                }
            })
        }

        

    </script>
</body>